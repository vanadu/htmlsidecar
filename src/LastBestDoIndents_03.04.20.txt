    // !VA This works for everything except embedded background image tags. This is totally hacked but it works and structurally it can be improved upon at some later date
    function doIndents(id, container) {
      // console.clear();
      console.log('doIndents running');
      var nodeList = container.querySelectorAll( '*' );
      // console.log('nodeList is:');
      // console.log(nodeList);
      // console.log('nodeList[0].innerHTML is: ' + nodeList[0].innerHTML);
      // console.log('childNodes:');
      // console.log(nodeList[0].childNodes);
      // console.log('nodeList[0].childNodes.length is: ' + nodeList[0].childNodes.length);
      // for (let i = 0; i < nodeList[0].childNodes.length; i++) {
      //   console.log('nodeList[0].childNodes[i] is: ' +  nodeList[0].childNodes[i]);
      // }
      let indentspacing, indent, i, nextSiblingIndex, previousSiblingIndex, loopCount, target, hasAnchor, output;
      // !VA Set the loop iterator to 0 and the indentspacing to two spaces
      let j;
      i = 0, indentspacing = '  ';


      // !VA If nodeList only contains a singleton img tag, nodeList[i] will be null, so we exclude that case
      if (nodeList.length > 0) {
        // !VA Get the index of the sibling nodes, i.e. the td nodes containing the two-column content.  
        for (i = 0; i < nodeList.length; i++) {
          if (nodeList[i].nextSibling) { nextSiblingIndex = i; }
          if (nodeList[i].previousSibling) {previousSiblingIndex = i;}
        }
        // !VA If there is an element with a sibling, then increment loopCount until that element's index is reached. If there's no element with a sibling, then set loopCount to the length of nodeList and process the entire nodeList.
        nextSiblingIndex ? loopCount = nextSiblingIndex : loopCount = nodeList.length;
        // !VA If the terminating img tag has an anchor tag wrapper, we don't want the terminating img element to be indented.So we need to find out whether the anchor is present
        target = ccpUserInput.spnCcpImgIncludeAnchorCheckmrk;
        hasAnchor = getCheckboxSelection(target);
        // !VA Loop through the elements and increase the indent with each iteration
        for (i = 0; i < loopCount; i++) {
          indent  =  '\n' + indentspacing.repeat([i]);
          // !VA If insert  anchor is checked
          if (hasAnchor) {
            // !VA Don't apply indents to the img element if insert anchor is checked 
            if (nodeList[i].nodeName === 'IMG') {
              // !VA This should be rewritten to deal with the empty if statement before the else
            } else {
              // !VA For all other elements, if insert anchor is checked and the current element is the A tag, apply the indent only to the opening tag
              if (nodeList[i].nodeName === 'A') {
                nodeList[i].insertAdjacentHTML('beforebegin', indent);
              } else {
                // !VA For all other elements except the A tag, apply the normal indents
                nodeList[i].insertAdjacentHTML('beforebegin', indent);
                nodeList[i].insertAdjacentHTML('beforeend', indent);
              }
            }
            // !VA Insert anchor is not checked, so apply the normal indents to all elements
          } else {
            nodeList[i].insertAdjacentHTML('beforebegin', indent);
            nodeList[i].insertAdjacentHTML('beforeend', indent);
          }
        }
        // !VA The number of elements below the sibling element is equal to the second sibling's index minus the first sibling's index -- that's the number of descendants separating the two siblings. Consequently, the first sibling's index is i and the second sibling's index is i + 5. So now loop through the siblings and their descendants, starting with the index of the first sibling. 
        loopCount = nextSiblingIndex + (previousSiblingIndex - nextSiblingIndex);
        for (i = nextSiblingIndex; i < loopCount; i++) {
          // !VA Increase the indent with each iteration. 
          indent  =  '\n' + indentspacing.repeat([i]);
          // !VA The terminating element in the tree gets no indent and no line break - the indent and line break are covered by its parent.
          if (i === nextSiblingIndex) { indent = ''; }
          // !VA Apply the indent to the nextSibling. 
          nodeList[i].insertAdjacentHTML('beforebegin', indent);
          nodeList[i].insertAdjacentHTML('afterend', indent);
          // !VA Apply the indent to the previousSibling
          nodeList[i + 5].insertAdjacentHTML('beforebegin', indent);
          nodeList[i + 5].insertAdjacentHTML('afterend', indent);
        }
      }
      output = nodeList[0].outerHTML; 
      writeClipboard( id, output);
    }
